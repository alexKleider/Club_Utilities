#!/usr/bin/env python3

# File: restore.py

"""
#### !!!!! WARNING  file location changed => code directory!! ####
Usage:
  $ ./restore.py src 

Requires one command line argument: the name of a tar.gz file which
is assumed to be one that has been generated by archive_data.py.
Replaces data files which are kept in the repo directory but
excluded from the repo itself.
"""

import os
import sys
import shutil
import tarfile
# Must first add the parent directory of the
# currently running script to the system path:
sys.path.insert(0, os.path.split(sys.path[0])[0])
# print(sys.path)
# ... or alternatively set PYTHONPATH to project directory:
# export PYTHONPATH=/home/alex/Git/Club/Utils
import rbc

# First part just checks that there is a valid parameter
# and assigns it to <target> (the full path of the gzip file) and
# from that derives <src_dir> (just the name of the gzip file)
# and <holder_dir> (a temporary directory into which the non-repo
# files/directories will be unziped :
if len(sys.argv) !=2:
    print("Must provide one command line argument: " +
          "the name of a tar.gz file!")
    sys.exit()
target = sys.argv[1]
src_dir = target.split('/')[-1]
print("Source directory is {}".format(src_dir))
parts = src_dir.split('.')
if len(parts) >= 3 and parts[-2:] == ['tar', 'gz']:
    holder_dir = parts[-3]
    print('Suffix is "{}" and temporary directory is "{}".'
          .format('.'.join(parts[-2:]), holder_dir))
else:
    print("Suffix isn't right!")
    sys.exit()
response = input("Continue? ")
if not (response and response[0] in ('y', 'Y')):
    sys.exit()

# Extract the tar file:
tar = tarfile.open(target)
tar.extractall()
tar.close()

# Check that we got what is expected:
expected_dirs = set(rbc.Club.NONREPO_DIRS)
existing_dirs = set(os.listdir(path='./{}'.format(holder_dir)))
if not expected_dirs == existing_dirs:
    print("Expected and existing list of directories don't match!")
    shutil.rmtree(holder_dir)
    sys.exit()


for folder in rbc.Club.NONREPO_DIRS:
    shutil.rmtree(folder)
    shutil.copytree(
        os.path.join(".", holder_dir, folder),
        os.path.join(".", folder),
#       dirs_exist_ok=True,
        )

# Clean up:
shutil.rmtree(holder_dir)
