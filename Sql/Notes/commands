
CREATE DATABASE PetHotel;  # not in sqlite!
$ sqlite3 sql.db

ATTACH DATABASE 'PetHotel.db' AS Pets;  # creates prn

CREATE TABLE PetTypes
(
    PetTypeId   int NOT NULL PRIMARY KEY,  # primary key constraint
    PetType     varchar(60) NOT NULL
);

Constraints can be added later with an ALTER TABLE statement.



SQLite requires an index to enforce the PRIMARY KEY constraint --
without an index, enforcing the constraint would slow dramatically
as the table grows in size. Constraints and indexes are not
identical, but I don't know of any relational database that does
not automatically create an index to enforce primary keys. So yes,
this is normal behavior for any relational database.

If the purpose of creating an index is to optimize searches where
you have an indexable search term that involves the first column
in the index then there's no reason to create an additional index
on the column(s) -- SQLite will use the automatically created one.

If your searches will involve the second column in the index without
including an indexable term for the first column you will need to
create your index. Neither SQLite (nor any other relational database
I know of) can use composite indexes to optimize filtering when the
head columns of the index are not specified in the search.

