diff --git a/Sql/Sanitized/applicants.txt b/Sql/Sanitized/applicants.txt
index 688e7ef..8c40898 100644
--- a/Sql/Sanitized/applicants.txt
+++ b/Sql/Sanitized/applicants.txt
@@ -25,7 +25,7 @@ Herbert Tully         | 200214 | 200214 | 200306 | 201204 | Application withdraw
 Jacob Murchant        | 220315 | 220315 | 220506 | 220701 | 221007 |
 George Applebaulm     | 220326 | 220326 | 220506 | 220603 | 220805 | 220831 | 221002 |
 Will Smithers         | 220506 | 220506 | 220506 | 220701 | 220805 | 220831 | waiting
-Carl Nesbitt          | 220805 | 220902 | 220902 | 221007 |
+Carl Nesbitt_Mr       | 220805 | 220902 | 220902 | 221007 |
 Lori Middleman        | 220915 | 220915 |
 # John Castle           | 221007 | 221007 | 221007 |
 Leam Rose             | 221007 | 221007 | 221104 |
diff --git a/Sql/add_data.py b/Sql/add_data.py
index 833a774..9360ff0 100755
--- a/Sql/add_data.py
+++ b/Sql/add_data.py
@@ -28,7 +28,7 @@ sponsor_text_file = 'Sanitized/sponsors.txt'
 def get_commands(sql_file):
     """
     Assumes <in_file> contains valid SQL commands.
-    i.e. could be read by sqlite3 > .read <in_file>
+    i.e. could be read by sqlite> .read <in_file>
     Yeilds the commands one at a time.
     Usage:
         con = sqlite3.connect("sql.db")
@@ -62,6 +62,15 @@ def return_name_suffix_tuple(name):
     else: return '', ''
 
 
+def shorten_rec(rec):
+    ret = {}
+    for key in rec.keys():
+        ret[key] = rec[key]
+        if key == 'email':
+            break
+    return ret
+
+
 def add_suffix_field(rec):
     """
     Returns a record with a 'suffix' field
@@ -103,7 +112,8 @@ def populate_people(source, connection, cursor):
     Note: a suffix field is added to each record.
     """
     for rec in data_generator(source):
-        ret = add_suffix_field(rec)
+#       ret = add_suffix_field(rec)
+        ret = shorten_rec(rec)
         keys = ', '.join([key for key in ret.keys()])
         values = [value for value in ret.values()]
         values = ', '.join([f"'{value}'" for value in ret.values()])
@@ -123,9 +133,60 @@ def get_applicant_data(applicant_source, sponsor_source):
     club.infile = 'Sanitized/members.csv'
     data.populate_sponsor_data(club)
     data.populate_applicant_data(club)
+#   _ = input(club.applicant_data)
     return club.applicant_data
 
 
+def one2two(name):
+    n = name.find('_')
+    suffix = name[n+1:]
+    if n > -1 and len(suffix) == 2:
+        return name[:-3], suffix
+    else:
+        return  name, ''
+
+
+def change_name_key(name):
+    last, first = name.split(',')
+    last, suffix = one2two(last)
+    return ','.join((last, first, suffix))
+
+
+def change_name_field(name_field):
+    first, last = name_field.split()
+    last, suffix = one2two(last)
+    return f"{first} {last} {suffix}"
+
+
+def fix_applicant_data(data):
+    """
+    Changes records to include 'suffix' field and keys
+    are name keys are changed from 'last,first' to
+    'last,first,suffix'.
+    """
+    ret = {}
+    for key in data.keys():
+        new_key = change_name_key(key)
+        ret[new_key] = {}
+        for subkey in data[key].keys():
+            if subkey == 'last':
+                last, suffix = one2two(data[key][subkey])
+                ret[new_key]['last'] = last
+                ret[new_key]['suffix'] = suffix
+                pass
+            elif subkey in ('sponsor1', 'sponsor2'):
+                if data[key][subkey]:
+                    ret[new_key][subkey] = change_name_field(
+                                        data[key][subkey])
+                else:
+                    ret[new_key][subkey] = data[key][subkey]
+            else:
+#               _ =  input(f"""{new_key} | {subkey} | {key} | {subkey}
+#{data[key][subkey]}""")
+                ret[new_key][subkey] = data[key][subkey]
+    return ret
+
+
 def populate_applicant_data(applicant_data, valid_names,
                                 con, cur):
     """
@@ -137,10 +198,10 @@ def populate_applicant_data(applicant_data, valid_names,
     for key in applicant_data.keys():
         names.add(key)
         sponsors = set()
-        for name in ('sponsor1', 'sponsor2'):
-            if name:
+        for sponsor in ('sponsor1', 'sponsor2'):
+            if applicant_data[key][sponsor]:
                 sponsors.add(helpers.tofro_first_last(
-                    applicant_data[key][name]))
+                    applicant_data[key][sponsor]))
         names.update(sponsors)
     if not set(valid_names).issuperset(names):
         _ = input(names.difference(set(valid_names)))
@@ -171,9 +232,12 @@ def main():
     populate_people(membership_csv_file, con, cur)
     # collect a set of valid name keys (people_keys)
     people_keys = get_people_keys(cur)
+#   print("people_keys:")
+#   _ = input(f"{people_keys}")
 
     applicant_data = get_applicant_data(applicant_text_file,
-                                        sponsor_text_file)
+                                sponsor_text_file)
+#   _ = input(applicant_data)
     populate_applicant_data(applicant_data, people_keys, con, cur)
     con.close()
 
diff --git a/Sql/concepts.txt b/Sql/concepts.txt
index cfebb5e..7fe3633 100644
--- a/Sql/concepts.txt
+++ b/Sql/concepts.txt
@@ -32,8 +32,10 @@ sqlite> .tables
 Employee  Salary
 sqlite>
 
->.help >> listing of 'dot commands' of which '.tables' is one.
-#see help.txt file...
+> .help >> listing of 'dot commands' of which '.tables' is one.
+    .quit
+    .read <a file of sql commands>
+    .tables
 
 Start the interpreter:
 -simply a case of calling it with a filename as an argument.
@@ -192,3 +194,65 @@ some strange behaviour if you are not aware of this foible. Most databases
 treat the type declaration as a strict constraint and will fail if an
 illegal value is passed.
 
+Extracting Data
+===============
+SELECT column1, column2... FROM table1, table2...; 
+sqlite> SELECT Name
+   ...> FROM Employee
+   ...> WHERE Employee.Grade = 'Labourer';
+                                ^  case sensitive!
+Could extend the condition using AND, OR, NOT etc.
+Dot notation is often needed:
+sqlite> SELECT Name, Amount FROM Employee, Salary
+   ...> WHERE  Employee.Grade = Salary.Grade  } and SQL
+   ...> AND    Salary.Amount > '50000';       } "join"*
+* https://www.guru99.com/sqlite-join.html
+** the SQL documentation for SELECT: http://www.sqlite.org/lang_select.html
+SELECT columns FROM tables WHERE expression ORDER BY columns;
+Can have any number of columns not necessarily just one:
+Note: WHERE clause (if used) must precede ORDER BY clause.
+
+Changing Data
+=============
+UPDATE tablename SET column = value WHERE condition;
+
+DELETE FROM Tablename WHERE condition
+So if we wanted to delete Anne Jones from our Employee table we could do this:
+sqlite> DELETE FROM Employee WHERE Name = 'Anne Jones';
+Also can use DROP command (to delete a whole table.
+
+Linking Data Across Tables
+==========================
+Data Constraints: applied when we define (CREATE) the database structure.
+The most common constraints are:
+    NOT NULL
+    PRIMARY KEY [AUTOINCREMENT]
+    UNIQUE (often used for non INTEGER type PRIMARY KEY columns)
+    DEFAULT value
+Note that the AUTOINCREMENT "keyword" is not actually used,
+rather it is implied from a type/constraint combination of
+INTEGER PRIMARY KEY. A quirk of the SQLite documentation
+that trips up! http://www.sqlite.org/faq.html
+Table Constraints: not discussed in any detail.
+Column Type Constraints:
+    TEXT
+    INTEGER
+    REAL
+    NUMERIC
+    BLOB
+    NULL 
+The modified SQL (using constraints) looks like this:
+sqlite> CREATE TABLE Employee (
+   ...> EmpID INTEGER pRIMARY kEY,
+   ...> Name NOT NULL,
+   ...> HireDate NOT NULL,
+   ...> Grade NOT NULL,
+   ...> ManagerID INTEGER
+   ...> );
+sqlite> CREATE TABLE Salary (
+   ...> SalaryID INTEGER PRIMARY KEY,
+   ...> Grade  UNIQUE,
+   ...> Amount INTEGER DEFAULT 10000
+   ...> );
+
+
diff --git a/Sql/create_tables.sql b/Sql/create_tables.sql
index 217fd1d..95463bd 100644
--- a/Sql/create_tables.sql
+++ b/Sql/create_tables.sql
@@ -7,7 +7,6 @@ CREATE TABLE People (
     PersonID INTEGER PRIMARY KEY,
     first TEXT NOT NULL,
     last TEXT NOT NULL,
-    suffix TEXT DEFAULT '',
     phone TEXT DEFAULT '',
     address TEXT DEFAULT '',
     town TEXT DEFAULT '',
@@ -36,8 +35,8 @@ CREATE TABLE Person_Status (
     statusID INTEGER NOT NULL
     );
 
-DROP TABLE IF EXISTS Applicant_Sponsor;
-CREATE TABLE Applicant_Sponsor (
+DROP TABLE IF EXISTS Applicant_Sponsors;
+CREATE TABLE Applicant_Sponsors (
     personID INTEGER NOT NULL,
     sponsorID INTEGER NOT NULL
     );
@@ -57,7 +56,7 @@ CREATE TABLE Applicant_Dates (
 DROP TABLE IF EXISTS Dues;
 CREATE TABLE Dues (
     personID INTEGER UNIQUE NOT NULL,
-    dues_owed INTEGER NOT NULL
+    dues_owed NUMERIC DEFAULT 100
     );
 
 DROP TABLE IF EXISTS Kayak_Slots;
diff --git a/Sql/specification b/Sql/specification
index bfe784d..9958ccf 100644
--- a/Sql/specification
+++ b/Sql/specification
@@ -1,3 +1,5 @@
+# My notes as to db design
+
 Field types: TEXT INTEGER REAL NUMERIC BLOB NULL 
 #  RDB: A set of tables of rows (records) and columns (fields) #
 #  where a cell in one table may refer to a row in another.    #
